# Enemy Follows

```jres
{
    "transparency16": {
        "data": "hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile1": {
        "data": "hwQQABAAAADMzMzMzMzMzLy7u7u7u7vLvMvMzMzMvMu8vMzMzMzLy7zMy8zMvMzLvMy8zMzLzMu8zMzLvMzMy7zMzLzLzMzLvMzMvMvMzMu8zMzLvMzMy7zMvMzMy8zLvMzLzMy8zMu8vMzMzMzLy7zLzMzMzLzLvLu7u7u7u8vMzMzMzMzMzA==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile2": {
        "data": "hwQQABAAAAAiIiIiIiIiIkJEREREREQkQiIiIiIiIiRCIiIiIiIiJEIiREQiIiIkQkJERCIkJCRCQiREJCQkJEJCREQiQiIkQkJERCRCIiRCQiREIiQkJEIiREQkJCQkQiIiIiIiIiRCIiIiIiIiJEIiIiIiIiIkQkRERERERCQiIiIiIiIiIg==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile3": {
        "data": "hwQQABAAAAB3d3d3d3d3d1dVVVVVVVV1V3d3d3d3d3VXd3d3d3d3dVdXVVVVVXd1V1dXV3d3d3VXV3VVd3d3dVdXV1d3d3d1V3d1dXV3d3VXd1VXdXd3dVd3dXV1d3d1V3dVVXV3d3VXd3d3d3d3dVd3d3d3d3d1V1VVVVVVVXV3d3d3d3d3dw==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile4": {
        "data": "hwQQABAAAABERERERERERFRVVVVVVVVFVEREREREREVURFRFRERERVRERVRERERFVFRVVUVEREVUVFVVVURFRVRUVVVVVUVFVFRVVVVVRUVUVFVVVURFRVRUVVVFRERFVERFVEREREVURFRFRERERVRERERERERFVFVVVVVVVUVERERERERERA==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile5": {
        "data": "hwQQABAAAACqqqqqqqqqqrq7u7u7u7uruqqqqqqqqqu6qqqqqqqqq7qqqqqqqqqruqqqqqqqqqu6qrurqqqqq7q6u7u7uqururq7u7u6q6u6qrurqqqqq7qqqqqqqqqruqqqqqqqqqu6qqqqqqqqq7qqqqqqqqqruru7u7u7u6uqqqqqqqqqqg==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "level": {
        "id": "level",
        "mimeType": "application/mkcd-tilemap",
        "data": "MTAxZTAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDEwMDAwMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDUwMDAwMDAwMDAwMDUwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjIwMjIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjIyMjIyMjIwMjAwMDAwMDAwMDAyMDIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMg==",
        "tileset": [
            "myTiles.transparency16",
            "myTiles.tile1",
            "myTiles.tile3",
            "myTiles.tile4",
            "myTiles.tile5",
            "myTiles.tile2"
        ]
    },
    "*": {
        "mimeType": "image/x-mkcd-f4",
        "dataEncoding": "base64",
        "namespace": "myTiles"
    }
}
```

```template
scene.onOverlapTile(SpriteKind.Player, myTiles.tile2, function (sprite, location) {
    game.over(false)
})
scene.onOverlapTile(SpriteKind.Player, myTiles.tile4, function (sprite, location) {
    game.over(true)
})
controller.A.onEvent(ControllerButtonEvent.Pressed, function () {
    mySprite.vy = -200
})
let mySprite: Sprite = null
scene.setBackgroundColor(11)
mySprite = sprites.create(img`
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 1 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 3 1 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 1 1 1 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    `, SpriteKind.Player)
mySprite.ay = 500
controller.moveSprite(mySprite, 100, 0)
tiles.setTilemap(tilemap`level`)
scene.cameraFollowSprite(mySprite)
tiles.placeOnRandomTile(mySprite, myTiles.tile3)
info.setLife(3)
```

## B·∫Øt ƒë·∫ßu @unplugged

N·ªëi ti·∫øp nh·ªØng g√¨ ƒë√£ l√†m ƒë∆∞·ª£c ·ªü ph·∫ßn tr∆∞·ªõc, ·ªü b√†i n√†y ch√∫ng ta s·∫Ω th√™m ƒë·ªô kh√≥ cho game b·∫±ng m·ªôt v√†i k·∫ª th√π nh√©.  

ƒê·ªìng th·ªùi ch√∫ng ta s·∫Ω thi·∫øt l·∫≠p c∆° ch·∫ø t∆∞∆°ng t√°c gi·ªØa nh√¢n v·∫≠t ch√≠nh v√† nh·ªØng k·∫ª ƒë·ªãch n√†y nh√©.

![Ti·∫øn h√†nh ch·ªânh s·ª≠a game](/static/skillmaps/platformer/platformer3.gif "Time to live dangerously!")


## Tri·ªáu h·ªìi k·∫ª ƒë·ªãch (ph·∫ßn 1)

**B·∫Øt ƒë·∫ßu v·ªõi vi·ªác l·ª±a ch·ªçn v·ªã tr√≠ [__*spawn*__](#spawnd "tri·ªáu h·ªìi") k·∫ª ƒë·ªãch .**  

ƒê·ªãa ƒëi·ªÉm n√†y ƒë∆∞·ª£c ƒë√°nh d·∫•u b·∫±ng d·∫•u **[ ! ]** m√†u t√≠m.
<hr/>

üî≤ K√©o kh·ªëi [__l·∫∑p__](#loopd "m·ªôt thao t√°c ƒë∆∞·ª£c l·∫∑p ƒëi l·∫∑p l·∫°i") ``||loops: for element [value] of [list]||``
r·ªìi th·∫£ v√†o ph√≠a cu·ªëi c·ªßa khay ``||loops: on start||``.

N√∫t [__list__](#listical  "danh s√°ch c√°c ƒë·ªëi t∆∞·ª£ng") trong kh·ªëi v√≤ng l·∫∑p ph√≠a tr√™n üëÜ s·∫Ω li·ªát k√™ v√† chi ph·ªëi v·ªã tr√≠ c√°c √¥ 
 **[ ! ]** m√†u t√≠m.
 Vi·ªác c·ªßa ta l√† x√°c ƒë·ªãnh v√† ƒëi·ªÅu ch·ªânh v·ªã tr√≠ c·ªßa c√°c √¥ n√†y.

üî≤ T√¨m v√† k√©o kh·ªëi ``||scene: array of all [ ] locations||`` ƒë∆∞a ra ngo√†i m√†n h√¨nh, ƒë·ªìng th·ªùi ƒë∆∞a n√≥ v√†o thay th·∫ø v·ªã tr√≠ c·ªßa n√∫t **list** trong kh·ªëi l·∫∑p.

üî≤ Nh·∫•n v√†o √¥ vu√¥ng x√°m r·ªìi ƒë·ªïi th√†nh bi·ªÉu t∆∞·ª£ng d·∫•u **[ ! ]** m√†u t√≠m.
<br/>

```blocks
let mySprite: Sprite = null
scene.setBackgroundColor(11)
mySprite = sprites.create(img`
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 1 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 3 1 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 1 1 1 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    `, SpriteKind.Player)
mySprite.ay = 500
controller.moveSprite(mySprite, 100, 0)
tiles.setTilemap(tilemap`level`)
scene.cameraFollowSprite(mySprite)
tiles.placeOnRandomTile(mySprite, myTiles.tile3)
info.setLife(3)
// @highlight
for (let value of tiles.getTilesByType(myTiles.tile5)) {

}
```

## M·ªôt ch√∫t l∆∞u √Ω @unplugged

Gi·ªù th√¨ m·ªói v·ªã tr√≠ xu·∫•t hi·ªán k·∫ª ƒë·ªãch s·∫Ω c√≥ s·ª± xu·∫•t hi·ªán l·∫∑p l·∫°i.  

S·ª≠ d·ª•ng h√†m l·∫∑p, ta c√≥ th·ªÉ chi ph·ªëi v·ªã tr√≠ v√† t·∫ßn xu·∫•t tri·ªáu h·ªìi k·∫ª ƒë·ªãch m·ªôt c√°ch ng·∫´u nhi√™n!


## Tri·ªáu h·ªìi k·∫ª ƒë·ªãch (ph·∫ßn 2)

üëæ H√£y th·ª≠ tri·ªáu h·ªìi v√†i k·∫ª ƒë·ªãch nh√© üëæ 
<hr/>

üî≤ K√©o kh·ªëi ``||variables: set [mySprite2] to sprite [ ] of kind [player]||`` 
v√†o khe tr·ªëng c·ªßa khay v√≤ng l·∫∑p.

üî≤ K√≠ch v√†o d√≤ng **mySprite2** r·ªìi ch·ªçn **new variable** ƒë·ªÉ t·∫°o m·ªôt gi√° tr·ªã m·ªõi ƒë·∫∑t t√™n n√≥ l√† **myEnemy**. 

üî≤ K√≠ch v√†o h√¨nh vu√¥ng n√†u x√°m r·ªìi thi·∫øt k·∫ø ngo·∫°i h√¨nh cho k·∫ª th√π nh√© (ho·∫∑c c√≥ th·ªÉ ch·ªçn m·∫´u c√≥ s·∫µn)

üî≤ K√≠ch v√†o d√≤ng **Player** r·ªìi ƒë·ªïi th√†nh **Enemy**  
<br/>

```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
scene.setBackgroundColor(11)
mySprite = sprites.create(img`
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 1 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 3 1 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 1 1 1 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    `, SpriteKind.Player)
mySprite.ay = 500
controller.moveSprite(mySprite, 100, 0)
tiles.setTilemap(tilemap`level`)
scene.cameraFollowSprite(mySprite)
tiles.placeOnRandomTile(mySprite, myTiles.tile3)
info.setLife(3)
for (let value of tiles.getTilesByType(myTiles.tile5)) {
// @highlight
    myEnemy = sprites.create(img`
        a a a a a a a a a a a a a a a a
        a b b b b b b b b b b b b b b a
        a b a a a a a a a a a a a a b a
        a b a a b b a a a a b b a a b a
        a b a a a a b a a b a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b b b b b b a a a b a
        a b a a b a a a a a a b a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b b b b b b b b b b b b b b a
        a a a a a a a a a a a a a a a a
        `, SpriteKind.Enemy)
}
```

##  Tri·ªáu h·ªìi k·∫ª ƒë·ªãch (ph·∫ßn 3)
Gi·ªù th√¨ ƒë√£ c√≥ k·∫ª ƒë·ªãch, nh∆∞ng ch√∫ng s·∫Ω xu·∫•t hi·ªán ·ªü c√πng m·ªôt ch·ªó, th·∫≠t nh√†m ch√°n.

H√£y thi·∫øt l·∫≠p ƒë·ªÉ ch√∫ng xu·∫•t hi·ªán m·ªói con ·ªü 1 d·∫•u **[ ! ]** . (C√°c d·∫•u n√†y s·∫Ω c√≥ v·ªã tr√≠ ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh d·ª±a v√†o tham s·ªë **value** ph·ª• thu·ªôc v√†o vi·ªác ch√∫ng ta ƒëi·ªÅu ch·ªânh v√≤ng l·∫∑p **for element**.)
<hr/>

üî≤ ƒê√†u ti√™n k√©o kh·ªëi ``||scene: place [mySprite] on top of tilemap col [0] row [0]||`` 
th·∫£ v√†o cu·ªëi khay ch·ª©a h√†m l·∫∑p **for element**.

üî≤ ƒê·ªïi t√™n **mySprite** th√†nh **myEnemy** r·ªìi ta k√©o thay th·∫ø ``||variables: value||`` t·ª´ tr√™n ƒë·∫ßu khay l·∫∑p **for element** xu·ªëng ƒë·ªÉ thay ch·ªó cho ``||scene: tilemap col [0] row [0]||``
<br/>

```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
scene.setBackgroundColor(11)
mySprite = sprites.create(img`
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 1 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 3 1 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 1 1 1 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    `, SpriteKind.Player)
mySprite.ay = 500
controller.moveSprite(mySprite, 100, 0)
tiles.setTilemap(tilemap`level`)
scene.cameraFollowSprite(mySprite)
tiles.placeOnRandomTile(mySprite, myTiles.tile3)
info.setLife(3)
for (let value of tiles.getTilesByType(myTiles.tile5)) {
    myEnemy = sprites.create(img`
        a a a a a a a a a a a a a a a a
        a b b b b b b b b b b b b b b a
        a b a a a a a a a a a a a a b a
        a b a a b b a a a a b b a a b a
        a b a a a a b a a b a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b b b b b b a a a b a
        a b a a b a a a a a a b a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b b b b b b b b b b b b b b a
        a a a a a a a a a a a a a a a a
        `, SpriteKind.Enemy)
        // @highlight
    tiles.placeOnTile(myEnemy, value)
}
```

## Enemy follow
üí§ Did you notice that we have the laziest enemies ever? üí§

Let's wake-up our sprites and get them following our player.
<hr/>
üî≤ Snap a ``||sprites: set [myEnemy] follow [mySprite]||`` block 
into the bottom of the **for element** loop.

üî≤ Change the first sprite argument to **myEnemy** and the second to **mySprite**.

üî≤ Press the **‚äï** on the new block and change the speed to **30**.
<br/>

```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
scene.setBackgroundColor(11)
mySprite = sprites.create(img`
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 1 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 3 1 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 1 1 1 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    `, SpriteKind.Player)
mySprite.ay = 500
controller.moveSprite(mySprite, 100, 0)
tiles.setTilemap(tilemap`level`)
scene.cameraFollowSprite(mySprite)
tiles.placeOnRandomTile(mySprite, myTiles.tile3)
info.setLife(3)
for (let value of tiles.getTilesByType(myTiles.tile5)) {
    myEnemy = sprites.create(img`
        a a a a a a a a a a a a a a a a
        a b b b b b b b b b b b b b b a
        a b a a a a a a a a a a a a b a
        a b a a b b a a a a b b a a b a
        a b a a a a b a a b a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b b b b b b a a a b a
        a b a a b a a a a a a b a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b b b b b b b b b b b b b b a
        a a a a a a a a a a a a a a a a
        `, SpriteKind.Enemy)
    tiles.placeOnTile(myEnemy, value)
    myEnemy.follow(mySprite, 30)
}
```

## Damage pt. 1 @unplugged

Now the enemies should be moving toward the player.

What happens when the enemies reach the player? **Nothing?!?**
Well, that's no fun.  
Let's add some code to make this more exciting.  
üòàüëøüòà &nbsp;  üò±  
<hr/>

**Our player and enemies might meet under a couple of different** 
[**_conditions_**](#condy "thing we need to know before deciding what happens next"):

1. **If the player jumps on an enemy, the enemy is destroyed**

2. **If the player runs into an enemy, 
the player takes damage and the enemy is destroyed**

<hr/>
We'll need an **on sprite overlap** event to know if these happen!

## Damage pt. 2
In both overlap cases, we want to destroy the enemy sprite...so 
let's code that part first.  
üí•üëøüí•
<hr/>

üî≤ From the ``||sprites: Sprites||`` category, drag an 
``||sprites: on [sprite] of kind [Player] overlaps [otherSprite] of kind [Player]||`` 
[__*event*__](#eventTime "element that makes something happen when a certain action is performed")
 container into the workspace.

üî≤ Leave the first kind as **Player** and change the second kind to **Enemy**.

üî≤ Snap a ``||sprites: destroy [mySprite]  ‚äï||`` block into the new event container.

üî≤ Drag the ``||variables: otherSprite||`` argument from the **on sprite overlaps** 
event to replace the ``||variables: mySprite||`` variable inside the destroy block.

```blocks
sprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy, function (sprite, otherSprite) {
    otherSprite.destroy()
})
```

## Damage pt. 4 @unplugged

‚ùó Here comes the exciting part ‚ùó

We need to figure out whether the enemy was **jumped on** or **run into**.  
**_THEN_**, based on that 
[**_condition_**](#condy "thing we need to know before deciding what happens next"),
 we need to run different code.

The ``||logic:if <true> then||`` block can make that happen.  

```block
    if (true) {
    }
```
<hr/>


## Damage pt. 5

üî≤ Start by adding an ``||logic:if <true> then||`` container to the end
of the newest **on sprite overlaps** container. 
<hr/>
The next part will take a little deep thinking  ü§Ø

In order to have reached the ``||logic:if <true> then||`` container, the 
program must already know that an enemy has overlapped the player. 
Now we just have to determine whether or not the player jumped on the enemy
from the top.  

In this case, we want to check that the bottom of the player was higher
than the center (**y**) of the enemy. Here's how to do that:

üî≤ Drag out a ``||logic:0 < 0||`` logic argument block and snap it into
``||logic:if <true> then||`` to replace the ** `<true>` ** argument.

üî≤ On the left-hand side of the **<**, place a ``||sprites:[mySprite] [x]||`` block and change 
the **x** to **bottom**, and replace **mySprite** with the **sprite** 
variable from the **on sprite overlaps** header.

üî≤ Right-click on the logic argument that you just finished to duplicate it. 

üî≤ Place the duplicate block to the right of the **<**. Replace **bottom** 
with **y** and replace **sprite** with **otherSprite**.  
<br/>


```blocks
sprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy, function (sprite, otherSprite) {
    otherSprite.destroy()
    if (sprite.bottom < otherSprite.y) {
    }
})
```

## Damage pt. 5.5
To add more style, let's make the player bounce after they've jumped on an enemy.
<hr/>

üî≤ Snap a ``||sprites:set [mySprite] [x] to ||`` block into the empty **if/then** 
logic container and replace **mySprite** with **sprite**.

üî≤ Replace **x** with **vy (velocity y)** using the dropdown menu.

üî≤ Change the value from **0** to **-100**.  
<br/>


```blocks
sprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy, function (sprite, otherSprite) {
    otherSprite.destroy()
    if (sprite.bottom < otherSprite.y) {
        sprite.vy = -100
    } 
})
```


## Damage pt. 6 @unplugged

Now we've written code that checks if the player has bounced on an enemy.  
**But what if it didn't?**

We need to add an option in case the player and enemy overlapped in a 
different way.  This catch-all condition is called an **else** clause. 
<hr/>

To add an **else** clause to our **if/then** logic, simply press
the **‚äï** at the bottom-left corner of the **if/then** container and one will appear!


```block

  sprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy, function (sprite, otherSprite) {
    otherSprite.destroy()
    // @highlight
    if (sprite.bottom < otherSprite.y) {
        sprite.vy = -100
    } else {
    }
})
```

## Damage pt. 6.6

Now that we have an **else** clause, we can use it
for anything that needs to run when the player and enemy
overlap in a non-jumping way. 
<hr/>

üî≤ To remove a life from the player under that condition, 
snap a ``||info: change life by [-1]||`` block into the empty **else** clause.  
<br/>

```ghost
        info.changeLifeBy(-1)
```

```blocks
sprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy, function (sprite, otherSprite) {
    otherSprite.destroy()
    if (sprite.bottom < otherSprite.y) {
        sprite.vy = -100
    } else {
    // @highlight
        info.changeLifeBy(-1)
    }
})
```

## Finish
üî• Fantastic üî•

The basic enemies tutorial is complete!  
Try defeating the level as is, then open the tilemap editor 
and see what happens if you add more spawn points.
